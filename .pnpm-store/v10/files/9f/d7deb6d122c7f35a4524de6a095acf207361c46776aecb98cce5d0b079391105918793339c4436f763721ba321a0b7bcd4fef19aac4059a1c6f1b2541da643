"use strict";
// *** WARNING: this file was generated by pulumi-gen-awsx. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
Object.defineProperty(exports, "__esModule", { value: true });
exports.Vpc = void 0;
const pulumi = require("@pulumi/pulumi");
const utilities = require("../utilities");
/**
 * The VPC component provides a VPC with configured subnets and NAT gateways.
 *
 * ## Example Usage
 *
 * Basic usage:
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as awsx from "@pulumi/awsx";
 *
 * const vpc = new awsx.ec2.Vpc("vpc", {});
 * export const vpcId = vpc.vpcId;
 * export const vpcPrivateSubnetIds = vpc.privateSubnetIds;
 * export const vpcPublicSubnetIds = vpc.publicSubnetIds;
 * ```
 *
 * ## Subnet Layout Strategies
 *
 * If no subnet arguments are passed, then a public and private subnet will be created in each AZ with default sizing. The layout of these subnets can be customised by specifying additional arguments.
 *
 * All strategies are designed to help build a uniform layout of subnets each each availability zone.
 *
 * If no strategy is specified, "Legacy" will be used for backward compatibility reasons. In the next major version this will change to defaulting to "Auto".
 *
 * ### Auto
 *
 * The "Auto" strategy divides the VPC space evenly between the availability zones. Within each availability zone it allocates each subnet in the order they were specified. If a CIDR mask or size was not specified it will default to an even division of the availability zone range. If subnets have different sizes, spaces will be automatically added to ensure subnets don't overlap (e.g. where a previous subnet is smaller than the next).
 *
 * ### Exact
 *
 * The "Exact" strategy is the same as "Auto" with the additional requirement to explicitly specify what the whole of each zone's range will be used for. Where you expect to have a gap between or after subnets, these must be passed using the subnet specification type "Unused" to show all space has been properly accounted for.
 *
 * ### Explicit CIDR Blocks
 *
 * If you prefer to do your CIDR block calculations yourself, you can specify a list of CIDR blocks for each subnet spec which it will be allocated for in each availability zone. If using explicit layouts, all subnet specs must be declared with explicit CIDR blocks. Each list of CIDR blocks must have the same length as the number of availability zones for the VPC.
 *
 * ### Legacy
 *
 * The "Legacy" works similarly to the "Auto" strategy except that within each availability zone it allocates the private subnet first, followed by the public subnets, and lastly the isolated subnets. The order of subnet specifications of the same type can be changed, but the ordering of private, public, isolated is not overridable. For more flexibility we recommend moving to the "Auto" strategy. The output property `subnetLayout` shows the configuration required if specifying the "Auto" strategy to maintain the current layout.
 */
class Vpc extends pulumi.ComponentResource {
    /**
     * Returns true if the given object is an instance of Vpc.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Vpc.__pulumiType;
    }
    /**
     * Create a Vpc resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name, args, opts) {
        let resourceInputs = {};
        opts = opts || {};
        if (!opts.id) {
            resourceInputs["assignGeneratedIpv6CidrBlock"] = args?.assignGeneratedIpv6CidrBlock;
            resourceInputs["availabilityZoneCidrMask"] = args?.availabilityZoneCidrMask;
            resourceInputs["availabilityZoneNames"] = args?.availabilityZoneNames;
            resourceInputs["cidrBlock"] = args?.cidrBlock;
            resourceInputs["enableDnsHostnames"] = args?.enableDnsHostnames;
            resourceInputs["enableDnsSupport"] = args?.enableDnsSupport;
            resourceInputs["enableNetworkAddressUsageMetrics"] = args?.enableNetworkAddressUsageMetrics;
            resourceInputs["instanceTenancy"] = args?.instanceTenancy;
            resourceInputs["ipv4IpamPoolId"] = args?.ipv4IpamPoolId;
            resourceInputs["ipv4NetmaskLength"] = args?.ipv4NetmaskLength;
            resourceInputs["ipv6CidrBlock"] = args?.ipv6CidrBlock;
            resourceInputs["ipv6CidrBlockNetworkBorderGroup"] = args?.ipv6CidrBlockNetworkBorderGroup;
            resourceInputs["ipv6IpamPoolId"] = args?.ipv6IpamPoolId;
            resourceInputs["ipv6NetmaskLength"] = args?.ipv6NetmaskLength;
            resourceInputs["natGateways"] = args?.natGateways;
            resourceInputs["numberOfAvailabilityZones"] = args?.numberOfAvailabilityZones;
            resourceInputs["region"] = args?.region;
            resourceInputs["subnetSpecs"] = args?.subnetSpecs;
            resourceInputs["subnetStrategy"] = args?.subnetStrategy;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["vpcEndpointSpecs"] = args?.vpcEndpointSpecs;
            resourceInputs["eips"] = undefined /*out*/;
            resourceInputs["internetGateway"] = undefined /*out*/;
            resourceInputs["isolatedSubnetIds"] = undefined /*out*/;
            resourceInputs["privateSubnetIds"] = undefined /*out*/;
            resourceInputs["publicSubnetIds"] = undefined /*out*/;
            resourceInputs["routeTableAssociations"] = undefined /*out*/;
            resourceInputs["routeTables"] = undefined /*out*/;
            resourceInputs["routes"] = undefined /*out*/;
            resourceInputs["subnetLayout"] = undefined /*out*/;
            resourceInputs["subnets"] = undefined /*out*/;
            resourceInputs["vpc"] = undefined /*out*/;
            resourceInputs["vpcEndpoints"] = undefined /*out*/;
            resourceInputs["vpcId"] = undefined /*out*/;
        }
        else {
            resourceInputs["eips"] = undefined /*out*/;
            resourceInputs["internetGateway"] = undefined /*out*/;
            resourceInputs["isolatedSubnetIds"] = undefined /*out*/;
            resourceInputs["natGateways"] = undefined /*out*/;
            resourceInputs["privateSubnetIds"] = undefined /*out*/;
            resourceInputs["publicSubnetIds"] = undefined /*out*/;
            resourceInputs["routeTableAssociations"] = undefined /*out*/;
            resourceInputs["routeTables"] = undefined /*out*/;
            resourceInputs["routes"] = undefined /*out*/;
            resourceInputs["subnetLayout"] = undefined /*out*/;
            resourceInputs["subnets"] = undefined /*out*/;
            resourceInputs["vpc"] = undefined /*out*/;
            resourceInputs["vpcEndpoints"] = undefined /*out*/;
            resourceInputs["vpcId"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Vpc.__pulumiType, name, resourceInputs, opts, true /*remote*/);
    }
}
exports.Vpc = Vpc;
/** @internal */
Vpc.__pulumiType = 'awsx:ec2:Vpc';
//# sourceMappingURL=vpc.js.map